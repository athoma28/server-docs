1 = Introduction
2 :pp: {plus}{plus}
3 
4 TigerGraph's REST API endpoints exist on the REST{pp} and the GSQL server. REST{pp} (or RESTPP) is the TigerGraph customized https://en.wikipedia.org/wiki/Representational_state_transfer[REST] server. Our API accepts URL-encoded query string parameters, https://www.json.org/json-en.html[JSON]-encoded request bodies and returns JSON encoded responses. This user guide provides information on how to engage with our REST APIs: the introduction section explains how to send requests, pass parameters, and format request bodies, while the subsequent sections describe in detail each endpoint and its input and output.
5 
6 To submit a request, send an HTTP request to the REST{pp} server or the GSQL server. xref:troubleshooting:system-administration-faqs.adoc#_how_can_i_find_out_the_port_of_a_service[By default], the REST{pp} server listens for requests at port 9000 and the GSQL server listens on port 14240. A request needs to specify five things:
7 
8 * The request method (`GET`, `POST`, `PUT`, or `DELETE`)
9 * The endpoint address
10 * Any required or optional request parameters in URL encoding
11 * For `POST` requests, a data payload (i.e., request body) in JSON encoding unless otherwise specified
12 * In some cases, request header parameters
13 
14 For requests that are sent to the GSQL server, the sender needs to provide TigerGraph user credentials for the request to be accepted. If authentication is enabled on the RESTPP server, a request token needs to be included in the request header as well.
15 
16 [NOTE]
17 ====
18 In a test or development environment, the requester may be on the same server as REST{pp}. In this case, the server IP is *localhost*.
19 ====
20 
21 == Query String Parameters
22 
23 TigerGraph's API endpoints accept parameters in URL encoding, which is straightforward in the case of string, number, and boolean values. However, some parameters are more complex and require specific formatting. The list below describes how to format the complex type parameter values when executing a query.
24 
25 [width="100%",cols="<34%,<33%,<33%",options="header",]
26 |===
27 |Parameter type |Description |Example
28 |`+SET+` or `+BAG+` of primitives |Assign multiple values to the same
29 parameter name. |A `+SET<INT> +`parameter named `+p1 +`is assigned 3
30 integers: +
31  +
32 *`+p1=1&p1=5&p1=10+`*
33 
34 |`+VERTEX+` with a defined type |Use the primary key of the vertex. a|
35 <b></b>
36 
37 A `+VERTEX<person>+` parameter named`+vp+` is assigned a vertex whose ID
38 is `+"person2"+`: +
39 +
40 *`+vp=person2+`*
41 
42 |`+VERTEX+` without a defined type |Use
43 `+<parameter_name>.<parameter_type> +`to specify the type of the
44 parameter, and also provide the primary key of the vertex. a|
45 <b></b>
46 
47 A `+VERTEX+` parameter named `+va+` is assigned a `+person+` type vertex
48 whose ID is`+"person1"+` +
49 +
50 *`+va=person1&va.type=person+`*
51 
52 |`+SET+` or `+BAG+` of vertices with a defined type |Same as a `+SET+`
53 or `+BAG+` of primitives, where the value for each element is the
54 primary key of the vertex. |A `+SET<VERTEX<person>>+` parameter named
55 `+vp+` is assigned two vertices with IDs `+person3+` and `+person4+`: +
56 +
57 *`+vp=person3&vp=person4+`*
58 
59 |`+SET+` or `+BAG+` of vertices without a defined type |The `+SET+` or
60 `+BAG+` must be treated as an array, specifying the order of the
61 elements with indices `++`,`++`, etc. a|
62 A `+SET<VERTEX>+` parameter named `+vp+`is assigned a `+person+` type
63 vertex with an ID of `+person1+` and a `+post+` type vertex with an ID
64 of `+11+` :
65 
66 *`+vp[0]=person1&vp[0].type=person&vp[1]=11&vp[1].type=post+`*
67 
68 |===
69 
70 == Input Data for `POST` requests
71 
72 Input data for `POST` requests should be in JSON format, unless the endpoint specifically accepts data in other formats. There are two ways to supply the data: inline or in a separate file.
73 
74 === *Inline Data*
75 
76 The data should be formatted as a single string without linebreaks. If using curl, use the `-d` __**__option, followed by the JSON string.
77 
78 .Syntax for a POST request with Inline Data Payload
79 
80 [source,bash]
81 ----
82 curl -X POST -d 'json_string' "http://server_ip:9000/path_to_endpoint?request_parameters"
83 ----
84 
85 
86 
87 The following example uses the `POST /graph` endpoint to insert one User type vertex whose ID is ``"id6``" into the graph called `"socialNet"`.
88 
89 .Example using inline input data
90 
91 [source,bash]
92 ----
93 curl -X POST -d '{"vertices":{"User":{"id6":{"id":{"value":"id6"}}}}}' "http://localhost:9000/graph/socialNet"
94 ----
95 
96 
97 
98 === *Data File*
99 
100 Often it will be more convenient for the input data to be in a separate file, especially if the data is large.
101 
102 For curl, use `--data-binary <path_to_file>` __**__as in the example below:
103 
104 .Syntax for a POST request with Payload Data File
105 
106 [source,bash]
107 ----
108 curl -X POST --data-binary <path_to_file> "http://server_ip:9000/path_to_endpoint?parameter1=<parameter1>"
109 ----
110 
111 
112 
113 === Formatting Data in JSON
114 
115 Data of primitive types, including `INT, UINT, FLOAT, DOUBLE, STRING, BOOL`, and `DATETIME`, as well as arrays and objects, follow the standard https://www.json.org/json-en.html[JSON Data Interchange Syntax]. This subsection describes how to format complex data types.
116 
117 [width="100%",cols="<34%,<33%,<33%",options="header",]
118 |===
119 |Data type |Description |Example
120 |`+SET+`, `+LIST+` or `+BAG+` of primitives |Use a JSON array of
121 primitive values. a|
122 A set of primitive values: `[1, 2, 3]`
123 
124 |`+VERTEX+` |Use a JSON object that has an`+id+` field +
125 +
126 whose value is the primary key of the +
127 +
128 vertex and a`+"type"+`field whose value +
129 +
130 is the type of the vertex. a|
131 A `+person+` vertex with an ID of `+"Tom"+`:
132 
133 `+{"id": "Tom", "type": "person"}+`
134 
135 |`+MAP+` |Use a JSON object that has two JSON
136 arrays with keys `+keyList+` and
137 `+valueList+`, each containing the keys and the values of the map respectively. +
138 
139 The order of items in the valueList should correspond to the order of
140 items in the keyList. a|
141 A map of nations and their capitals:
142 
143 `+{"keyList": ["England", "Germany"],+`
144 
145 `+"valueList": }+`
146 
147 |User-Defined Type (UDT) |Use a JSON object that has two JSON +
148 +
149 arrays with keys `+keyList+` and +
150 +
151 `+valueList+`. The `+keyList+` array contains the field names of the
152 tuple, and the `+valueList+` array contains the values of the fields. +
153 +
154 +
155 +
156 The order of items in the valueList should correspond to the order of
157 items in the keyList. a|
158 Tuple schema definition:
159 
160 `+TYPEDEF TUPLE <name STRING, age INT> person+`A `+person+` tuple
161 written in JSON:
162 
163 `+{"keyList: ["name", "age"], "valueList": ["Sam", 24]}+`
164 
165 |===
166 
167 .Example: UDT Definition 
168 
169 [source,gsql]
170 ----
171 TYPEDEF TUPLE <field1 INT(1), field2 UINT, field3 STRING(10), field4 DOUBLE> myTuple
172 ----
173 
174 
175 ==== Vertices with Composite Keys
176 
177 If a vertex has a composite key composed of N attributes, then N values must be provided for the `"id"` . The values can be presented either as a JSON object with N key-value pairs, or as a JSON array with a list of N values in the same order as defined in the schema.
178 
179 The example below shows the two methods for a  vertex `v` having a composite primary key composed of the three attributes `id`, `name`, and `label.`
180 
181 [tabs]
182 ====
183 Option 1::
184 +
185 --
186 .Vertex v with composite key as JSON object
187 [source,javascript]
188 ----
189 {
190   "v": {
191     "id": {
192       "id": 3,
193       "name": "c",
194       "label": 300
195     },
196     "type": "v3"
197   }
198 }
199 ----
200 --
201 Option2::
202 +
203 --
204 .Vertex v with composite key as JSON array
205 [source,javascript]
206 ----
207 {
208   "v": {
209     "id": {
210       "id": [3, "c", 300] // The values in the array must be in the same
211                           // order as they are defined in the schema
212     },
213     "type": "v3"
214   }
215 }
216 ----
217 --
218 ====
219 
220 ==== `SET` or `BAG` of Vertices
221 
222 To describe a `SET` or `BAG` of vertices in JSON, use a JSON array with _vertex objects_ nested in the `SET` or `BAG` array.
223 
224 == Output Responses
225 
226 All TigerGraph REST responses are in JSON format. The output JSON object has four fields: `"version"`, `"error"`, `"message"`, and `"result"`.
227 
228 * `"version"` - this field describes the version of the running TigerGraph instance.
229 * "``error"`` - a boolean value to indicate if there is an error in processing the request. If there is an error, the `"error"` field will be `true`.
230 * `"message"` - the error message when there is an error. If a request is successful, the field will be an empty string or a brief message conveying the result of the request.
231 * `"results"` - this field contains the resulting data from the request. Details about the result of each built-in endpoint are described in the xref:built-in-endpoints.adoc[Built-in Endpoints] section.
232 
233 [source,javascript]
234 ----
235 // Example response
236 {
237   "version": {
238     "api": "v2",
239     "schema": 0
240   },
241   "error": false,
242   "message": "",
243   "results": [
244     {
245       "v_id": "id1",
246       "v_type": "User",
247       "attributes": {}
248     }
249   ]
250 }
251 ----
252 
253 [NOTE]
254 ====
255 To make the JSON output more human-readable in the terminal, use the https://stedolan.github.io/jq/[`jq`] command or Python json library built into most Linux installations:
256 
257 [source,bash]
258 ----
259 curl -X method "http://server_ip:9000/path_to_endpoint?request_parameters" | jq .
260 curl -X method "http://server_ip:9000/path_to_endpoint?request_parameters" | python -m json.tool
261 ----
262 
263 ====
264 
265 == Size and Time limits
266 
267 The maximum length for the request URL is 8K bytes, including the query string. Requests with a large parameter size should use a data payload file instead of inline data.
268 
269 === Request Body Size
270 
271 The maximum size for a request body, including the payload file, is set by the system parameter `Nginx.ClientMaxBodySize`. The default value is 200 (in MB). To increase this limit, use the following `gadmin` command:
272 
273 [source,text]
274 ----
275 gadmin config set Nginx.ClientMaxBodySize NNN
276 ----
277 
278 The upper limit of this setting is 1024 MB. Raising the size limit for the data payload buffer reduces the memory available for other operations, so be cautious about increasing this limit.
279 
280 === GSQL Query Timeout
281 
282 By default, an HTTP request in the TigerGraph system times out after 16 seconds.  to customize this timeout limit for a particular query instance, you can set the GSQL-TIMEOUT parameter in the request header. If you are using curl to submit your RESTPP request, the syntax would be the following:
283 
284 [source,bash]
285 ----
286 curl -X <GET/POST> -H "GSQL-TIMEOUT: <timeout value in ms>" '<request_URL>'
287 ----
288 
289 === Response Size
290 
291 You can specify the response size limit of an HTTP request with the following header:
292 
293 [source,bash]
294 ----
295 curl -X <GET/POST> -H "RESPONSE-LIMIT: <size limit in byte>" '<request_URL>'
296 ----
297 
298 If the response size is larger than the given limit, an error message will be returned instead of the actual query result:
299 
300 [source,bash]
301 ----
302 {
303   "error": true,
304   "message": "The query response size is 256MB, which exceeds limit 32MB.",
305   "results": [],
306   "code": "REST-4000"
307 }
308 ----
309 
310 == `curl` options
311 
312 Request examples in this guide are made using https://curl.se/docs/manpage.html[`curl`]. Below is a list of `curl` options used in our code examples:
313 
314 * `-d <data>`
315  ** Sends the specified data in a `POST` request to the HTTP server in the same way that a browser does when a user has filled in an HTML form and presses the submit button. This will cause curl to pass the data to the server using the content-type `application/x-www-form-urlencoded`.
316  ** If you start the data with the character `@`, the rest should be a filepath from which to read the data. The command `curl -d @foobar` will read data from a file named `foobar`.
317 * `--data-binary <data>`
318  ** Sends data with a `POST` request exactly as specified with no extra processing.
319 * `--fail`
320  ** Makes curl fail silently (no output at all) on server errors.
321  ** This is mostly done to enable scripts etc. to better deal with failed attempts. In normal cases when an HTTP server fails to deliver a document, it returns an HTML document stating so (which often also describes why and more). This flag will prevent curl from outputting that and return error 22.
322 * `-H <header>`
323  ** Extra header to include in the request when sending HTTP to a server. You may specify any number of extra headers.
324  ** TigerGraph APIs use headers to specify xref:API:intro.adoc#_size_and_time_limits[size and time limits], as well as to provide RESTPP xref:authentication.adoc#_rest_server_requests[authentication] tokens.
325 * `-s`
326  ** Silent or quiet mode. Don't show a progress meter or error messages. It will still output the data you ask for, potentially even to the terminal/stdout unless you redirect it.
327 * `-u <user:password>`
328  ** Submits the specified user name and password for server authentication.
329 * `-X <request_method>`
330  ** Specifies a custom request method to use when communicating with the HTTP server. If this option is not used, curl will make a `GET` request by default.
